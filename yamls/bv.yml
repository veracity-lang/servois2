
# Bitvector manipulator
#
# See: https://smtlib.cs.uiowa.edu/version1/logics/QF_BV.smt

name: bv

state:
  - name: b
    type: (_ BitVec 32)

states_equal:
  definition: (bvcomp b_1 b_2 bit1)

preamble: "(define-fun bveq ((bA BitVec[m]) (bB BitVec[m])) (bvcomp bA bB bit1)) (define-fun bvisset ((bA BitVec[m]) (pos Int)) (_ extract pos (+ pos 1) bA))"

methods:
  - name: negate
    args: []
    return:
      - name: result
        type: Bool
    requires: |
      true
    ensures: |
      (and (bvneg b b_new)
           (= result true))
    terms:
      BitVec[m]: [b, (bvneg b)]
  - name: shr1
    args: []
    return:
      - name: result
        type: Bool
    requires: |
      true
    ensures: |
      (and (bveq b_new (bvlshr b 1)) (= result true))
    terms:
      BitVec[m]: [b, (bvlshr b 1)]
      Int: [0, (- m 1)]

predicates:
  - name: "bveq"
    type: [BitVec[m], BitVec[m]]
  - name: "bvisset"
    type: [BitVec[m], Int]


# (set-logic QF_BV) 
# (set-option :produce-models true)

# (declare-const x_0 (_ BitVec 32))
# (declare-const x_1 (_ BitVec 32))
# (declare-const x_2 (_ BitVec 32))   
# (declare-const y_0 (_ BitVec 32))
# (declare-const y_1 (_ BitVec 32))   
# (assert (= x_1 (bvadd x_0 y_0))) 
# (assert (= y_1 (bvsub x_1 y_0)))
# (assert (= x_2 (bvsub x_1 y_1)))

# (assert (not
#   (and (= x_2 y_0)
#        (= y_1 x_0))))
# (check-sat)
# ; unsat
# (exit)
